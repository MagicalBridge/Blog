给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树.

例如：
给定 BST [1,null,2,2],
```
1
  \
    2
  /
2
```

返回 [2]

提示：如果众数超过1个，不需考虑输出顺序。

方法一: 中序遍历

思路与算法

首先，我们一定能够想到一个最朴素的做法: 因为这棵树的中序遍历是一个有序的序列，所以我们可以先获得这棵树的中序遍历，然后重新扫描这个中序遍历的序列，然后用一个哈希表来统计每个数字出现的个数，这样就可以找出出现次数最多的数字。但是这样做的空间复杂度显然不是O(1)的，原因是哈希表和保存中序遍历序列的空间代价都是O(n)。

实现中序遍历。

