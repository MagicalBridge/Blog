前言：

本题要求我们实现一个算法，将给定数字序列重新排列成字典序中下一个更大的排列。

以数字序列 [1,2,3] 为例子，其排列按照字典序依次为：
```
  [1,2,3]
  [1,3,2]
  [2,1,3]
  [2,3,1]
  [3,1,2]
  [3,2,1]
```

这样，排列[2,3,1]的下一个排列为[3,1,2],特别的，最大的排列为 [3,2,1]的下一个排列为最小的排列 [1,2,3]。

方法一: 两遍扫描。

思路和算法

注意到下一个排列总是比当前的要大，除非该排列已经是最大的排列，我们希望找到一种方法，能够找到大于当前序列的新的序列，且变大的幅度尽可能的小，具体地:

1、我们需要一个左边的「较小数」与一个右边「较大数」交换，能够让当前排列变大，从而得到下一个排列。
2、同时。我们要让这个「较小数」尽可能靠右，而「较大数」尽可能小，当交换完成以后，「较大数」右边的数字需要按照升序重新排列，这样可以在保证新排列大于原来排列的情况下，使得变大的幅度尽可能小。

拿[4,5,2,6,3,1]为例子:
* 我们找到符合条件的一对「较小数」和 「较大数」的组合是 2与3，满足「较小数」尽量靠右，而「较大数」尽可能小。
* 当我们完成交换后序列变为[4,5,3,6,2,1],这个时候，我们可以重新排列「较大数」的右边序列,序列变为 [4,5,3,1,2,6]。

具体地，我们这样描述该算法。对于长度为n的排列 a:
  1、首先从后往前查找第一个顺序对(i,i+1), 满足 a[i] < a[i+1], 这样 「较小数」即为 a[i]，此时[i+1,n]必然是下降序列。
  2、如果找到了顺序对，那么在区间[i+1,n]中从后向前查找第一个元素j满足 a[i] < a[j].这样「较大数」即为a[j].
  3、交换a[i]和a[j],此时可以证明区间[i+1,n]必然为降序，我们可以直接使用双指针翻转区间[i+1,n)，使得变为升序，而无需对该区间进行排序。

—————— 根本理解不太了。虽然思路很简单

我们可以将这个问题转化描述为: 给定若干个数字, 将其组合成一个整数，如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为:

```
123456
123465
123546
...
654321
```

可以看到有这样的关系：123456 < 123465 < 123546 < ... < 654321。

算法推导

1、我们希望下一个数比**当前的数大**, 这样才满足"下一个排列"的定义，因此只需要将后面的「大数」与前面的「小数」交换，
就能得到一个更大的数，比如123456，将5和6进行交换就能得到一个更大的数 123465。

2、我们还希望下一个数增加的幅度尽可能小，这样才能满足"下一个排列与当前排列紧邻"的要求，为了满足这个要求，我们需要:
  1、在尽可能的靠右侧的低位进行交换，需要从后往前查找。
  2、将一个尽可能小的「大数」与前面的「小数」交换，比如 123465 下一个排列应该把 5和 4进行交换，而不是把6和4进行交换。
  3、将「大数」换到前面后，需要将「大数」后面的所有的数重置为升序，升序排列就是最小的排列。以 123465 为例子: 首先按照上一步，交换5和4, 得到123564, 然后需要将5之后的数重置为升序 得到 123546显然， 123546 比 123564 更小，123546 就是 123465 的下一个排列。

算法过程
标准的"下一个排列“算法可以描述为:
  1、从后向前查找第一个**相邻升序**（这个部分措辞一定是谨慎的相邻和升序两个限定都不能少）的元素（i，j）, 满足 A[i] < A[j], 此时[j,end)必然是降序。
  2、在[j,end) 从后往前查找第一个满足A[i] < A[k]的k, A[i]、A[k]分别就是上文所说的「小数」、「大数」。
  3、将A[i]与A[k],进行交换。
  4、可以判定这个时候 [j, end)必然是降序，逆置[j,end),使其升序。
  5、如果在步骤1找不到符合的相邻元素对，说明当前[begin,end] 为一个降序顺序，则直接跳步骤4。







