@lc app=leetcode.cn id=3 lang=java

[3] 无重复字符的最长子串

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

示例  1:

输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是  "wke"，所以其长度为 3。
请注意，你的答案必须是子串的长度，"pwke"  是一个子序列，不是子串。

这道题目说的很明白要求的是最长的子串而不是子序列,因此找出的结果必须是连续的。这道题目，我们可以假想维护一个可以滑动的窗口,窗口,窗口内部都是没有重复的字符,我们需要尽可能的扩大窗口的大小，由于窗口在不停的向右边滑动，所以我们只关心每个字符最后出现的位置，并建立映射，窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要建立一个变量 left 来指向滑动窗口的左边界，这样，如果当前遍历到的字符从没有出现过，那么直接扩大右边界，如果之前出现过，那就分为两种情况在或者不在滑动窗口内，如果不在滑动窗口内，那么久没有关系当前字符可以加进来，如果在的话，就需要在滑动窗口去掉这个已经出现过的字符，去掉的方法并不是将左边界 left 一位一位向右遍历查找。我们可以直接移动 left 指针，同时我们维护一个结果 res，用窗口大小来更新 res 就可以得到我们想要的结果。

```java 
class Solution {
  public int lengthOfLongestSubstring(String s) {
    // 判断边界条件,如果传入的字符串为空，或者长度为0 返回的就是0;
    if (s == null || s.length() == 0) {
        return 0;
    }
    // 设置 返回的结果长度是0；左边的边界是-1 因为初始化的时候
    // 遍历是从第一个数字开始的。
    int res = 0;
    int left = -1;
    // 创建hashMap 映射字符串 和字符串出现的位置
    HashMap<Character, Integer> map = new HashMap<>(256);
    for (int i = 0; i < s.length(); i++) {
        // 关键的逻辑 如果遍历的到的字母在窗口中出现了 并且出现的位置 要大于left 之前的索引
        if (map.containsKey(s.charAt(i)) && map.get(s.charAt(i)) > left) {
            // 更新left的值
            left = map.get(s.charAt(i));
        }
        map.put(s.charAt(i), i);
        res = Math.max(res, i - left);
    }
    return res;
  }
}
```
