模块化之于程序，就如同细胞之于生命体，是具有特定功能的组成单元，不同的模块负责不同的工作，它们以某种方式联系在一起，共同保证程序的正常运转。本文将包含以下几个部分：
 + 1 不同的模块标准以及它们之间的区别；
 + 2 如何编写模块
 + 3 模块打包的原理

随着`JavaScript`的发展，社区中产生了很多的模块标准，在认识这些标准的同事，也要了解背后的思想。例如，它为什么会有这个特性，或者为什么要这样去实现，这对于我们自己编写模块也有所帮助。

## `CommonJS`
`CommonJS` 是由`JavaScript`社区于 2009年提出的包含模块、文件、IO、控制台在内的一系列标准。在`Node.js`js的实现中采用了`CommonJS`标准的一部分，并在其基础上进行了一些调整，我们所说的`CommonJS`模块和`Node.js`.js中的实现并不完全一样，现在一般谈到`CommonJS`其实是`Node.js`的版本，而非它的原始定义。

`CommonJS`最初只为服务器设计，直到 `Browserify` -- 一个运行在`Node.js`环境下的模块打包工具，它可以将 `CommonJS`模块打包为浏览器可以单独运行的单个文件。这意味着客户端的代码也可以遵循`CommonJS`标准来编写。

不仅如此，借助`Node.js`的包管理器，npm开发者还可以获取他人的代码库，或者把自己的代码发布上去供他人使用，这种可以共享的传播的方式使的`CommonJS`在前端开发中逐渐流行起来。

### 模块
`CommonJS` 中规定每一个文件是一个模块。将一个`JavaScript`文件直接通过script标签插入页面中与封装成`CommonJS`模块最大的不同在于，前者的顶层作用域是全局作用域，在进行变量声明时会污染全局作用域；而后者会形成一个属于模块自身的作用域，所有的变量以及函数只有自己能够访问，对外是不可见的：
```js
// calculator.js
var name = 'calculater.js';

// index.js
var name = 'index.js';
require('./calculater.js');
console.log(name); // index.js
```
这里有两个文件，在index.js 中我们通过 CommonJS 的require函数加载 calculater.js运行之后控制台结果是 'index.js'，这说明 calculater.js中的变量声明并不会影响 index.js 可见每一个模块是拥有各自作用域的。

### 导出
导出是一个模块向外暴露自身的唯一方式。在CommonJS中，通过module.exports可以导出模块中的内容，如：
```js
module.exports = {
  name:'calculater',
  add:function(a,b) {
    retturn a+b;
  }
};
```
CommonJS 模块内部会有一个module对象用于存放当前模块信息，可以理解成在每一个模块的最开始定义了以下对象：
```js
var module = {...};
// 模块自身的逻辑
module.exports = {...};
```
module.exports 用来指定该模块对外暴露哪些内容，在上面的代码中我们导出了一个对象，包含name 和add 两个属性，为了书写方便，
CommonJS也支持另一种简化的导出方式——直接使用exports.
```js
exports.name = 'calculater';
exports.add = function(a,b) {
  return a+b;
};
```
在实现效果上，这段代码和上面的module.exports没有任何不同，其内在机制是将exports 指向了 module.exports，而module.exports在初始化的时候是一个空的对象，我们可以简单的理解为CommonJS在每个模块的首部默认添加了以下代码：
```js
var module = {
  exports:{}
};

var exports = module.exports
```

因此，为exports.add 赋值相当于  module.exports 对象上添加一个属性。

在使用 exports 时候要注意一个问题，即不要直接给exports 赋值，否则会导致失效。如：

```js
exports = {
  name:'calculater'
}
```

上面的代码中，由于对exports进行了赋值操作，使其指向了新的对象，module.exports却仍然是原来的空对象，因此name属性并不会被导出。

另一个在导出时候容易犯的错误是不恰当的把module.exports于exports混用。

```js
exports.add = function(a,b){
  return a+b;
};

module.exports = {
  name:'calculater'
}
```
上面的代码先通过exports导出了add 属性，然后将module.exports重新赋值为另一个对象。这会导致原本拥有add属性的对象丢失了，最后导出的只有name。

另外 要注意导出语句不代表模块的末尾，在module.exports 或者 exports 后面的代码依旧照常执行。比如下面的console会在控制台上打出 'end'：

```js
module.exports = {
  name:'calculater',
};

console.log('end')
```
在实际开发中，为了提高可读性，不建议采取上面的写法，而是应该将 module.exports以及export语句放在模块的末尾。

### 导入

在CommonJS中使用require进行模块导入。如：
```js
// calculator.js

module.exports = {
  add: function(a,b){
    return a+b;
  };
};

// index.js
const calculator = require('./calculator.js');
const sum = calculator.add(2,3);
console.log(sum) // 5 
```

我们在index.js 中导入了calculator模块，并调用了它的add 函数。

当我们require一个模块的时候会有两种情况：
  + require的模块是第一次被加载。这时候会首先执行这个模块，然后导出内容。
  + require的模块被曾经加载过，这时候该模块的代码不会再次执行，而是直接导出上次执行后的结果。

请看下面的例子：
```js
// calculator.js
console.log('running calculator.js');
module.exports = {
  name:'calculator',
  add: function(a,b){
    return a+b;
  };
}
// index.js
const add = require('./calculator.js').add;
const sum = add(2,3);
console.log('sum:',sum);
const moduleName = require('./calculator.js').name;
console.log(name)
```
控制台输出如下结果：

```js
running calculator.js
sum:5
end
```
从结果可以看出，尽管我们有两个地方都调用了require('./calculator.js') 但是其实内部代码只执行了一遍。

我们前面提到，模块会有一个`module`对象存放其信息，这个对象中有一个属性loaded 用于记录该模块是否被加载过。他的值默认为false，当模块第一次被加载和执行过后置为true，后面再次加载时候回检查module。loaded 为true 则不会再次执行模块代码。

有时候我们加载一个模块，不需要获取其导出的内容，只是想想要通过执行它而产生某种作用，比如把它的接口挂载在全局对象上，此时直接使用require即可。

```js
require('./task.js')
```

另外，require 函数可以接收表达式，借助这个特性我们可以动态的指定模块的加载路径。

```js
const moduleName = ['foo.js','bar.js'];
moduleNameforEach(name => {
  require('./'+name)
})
```

## ES6 Module
在JavaScript被设计之初，原本并没有包含模块的概念，基于越来越多的工程需求，为了使用模块化进行开发JavaScript社区中出现了多种模块的标准，一直到2015年6月，TC39标准委员会正式发布了ES6 从此JavaScript语言才具有了模块这一个特性。

### 模块

请看下面的例子,我们将前面的 calculator.js 和 index.js 使用ES6方式进行了改写。
```js
// calculator.js
export defaut {
  name: 'calculator',
  add:function() {
    return a+b
  }
}

// index.js
import calculator from './calculator.js';
const sum =  calculator.add(2,3);
console.log(sum); // 5
```

ES6 Module 也是将每一个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。import 和 export 也作为保留关键字在ES6版本中加了进来，（CommonJS中module并不属于关键字）。

ES6 Module 会自动的采用严格模式，这在ES5 中是一个可选项，以前我们在文件开始添加 'use strict' 来控制是否开启严格模式，

### 导出

在ES6 Module 中使用export 命令来导出模块。export 有两种模式：
  + 命名导出
  + 默认导出
一个模块可以有多个命名导出，它有两种不同的写法：
```js
// 写法1
export const name = 'calculator';
export const add = function(a,b) {
  return a+b
}

// 写法2
const name = 'calculator';
const add = function(a,b) {
  return a+b
}
export { name, add}
```

第一种写法是将变量的声明和导出写在同一行；第二种则是先进行变量声明，然后再用同一个export语句导出，两种写法的效果是一样的。

在使用命名导出的时候，可以使用as关键字对变量重命名。如：
```js
const name = 'calculator'
const add = function(a,b) {return a+b};
export {
  name,
  add as getsum // 在导入时即为name 和 getSum
};
```
与命名导出不同，模块的默认导出只能由一个： 如：
```js
export default {
  name:'calculator',
  add: function(a,b) {
    return a+b
  }
}
```
我们可以将export default 理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。

```js
// 导出字符串
export default 'this is calculator.js'

// 导出 class
export default class {...}

// 导出匿名函数
export default function() {...}
```

### 导入
ES6 Module 中使用import语法导入模块。首先我们来看如何加载带有命名导出的模块，请看下面的例子：
```js
// calculator.js
const name = 'calculator';
const add  = function(a,b) {
  return a+b
}
export {name,add}

// index.js
import {name,add} from './calculator.js'
add(2,3)
```

加载带有命名导出的模块时,import后面要跟一对大括号来将导入的变量名包裹起来，并且这些变量名需要与导出的变量名完全一致。导入变量的效果相当于在当前作用域下声明了这些变量（name和add）,并且不可对其更改，也就是所有导入的变量都是只读的。

与命名导出类似，我们可以通过as 关键字对导入的变量重新命名。如：
```js
import {name ,add as calculateSum} from 'calculator.js'
calculateSum(2,3);
```
在导入多个变量时，我们还可以采用整体导入的方式。如：
```js
import * as calculator from 'calculator.js'
console.log(calculator.add(2,3))
console.log(calculator.name)
```
使用 import * as <myModule>可以把所有导入的变量作为属性值添加到 <myModule> 对象中，从而减少了对当前作用域的影响。

接下来处理默认导出，请看下面这个例子：

```js
// calculator.js
export default {
  name: 'calculator',
  add:function(a,b){
    return a+b;
  }
}

// index.js
import myCalculor from './calculator.js'
calculator.add(2,3)
```
对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculor）,它指代了calculator.js 中默认导出的值。从原理上可以这样去理解：
```js
import {default as myCalculator} from './calculator.js'
```

最后看一个两种导入方式混合起来的例子：
```js
// index.js
import React,{Component} from 'react'
```

这里的React对应的是该模块默认导出，而 Component则是其命名导出中的一个变量。

## CommonJS 与 ES6 Module 的区别

上面我们分别介绍了 CommonJS 和 ES6 Module 两种形式的模块定义，在实际开发过程中我们经常会将两者混用，因此需要对比一下它们的各自特性。

### 动态与静态 

CommonJS 和 ES6 Module最本质的区别在于前者对模块依赖的解决是“动态的“，而后者是”静态的”，在这里“动态”的含义是，模块依赖关系的建立是发生在代码运行阶段；而“静态” 则是模块依赖关系的建立发生在代码编译阶段。

让我们先看一个CommonJS的例子：
```js
// calculator.js
module.exports = { name: 'calculator' };
// index.js
const name = require('./calculator.js').name;
```
在上面介绍CommonJS的部分时我们提到过，当模块A加载模块B时（在上面的例子中是index.js 加载calculator.js）,会执行B中的代码，并将其module.exports 对象作为require函数的返回值进行返回。并且require的模块路径可以动态指定，支持传入一个表达式，我们甚至可以通过if语句判断是否加载某个模块。因此，在CommonJS 模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

同样的例子，让我们再对比下ES6 Module的写法：
```js
// calculator.js 
export const name = 'calculator';

// index.js
import { name } from './calculator.js'
```
ES6 Module 的导入、导出语句都是声明式的，它不支持导入的路径是一个表达式，并且导入、导出语句必须位于模块的顶层作用域（比如不能放在if语句中）。因此我们说，ES6 Module 是一种静态的模块结构，ES6代码的编译阶段就可以分析出模块的依赖关系，它相比CommonJS来说具备以下几点优势：

  + 死代码的检测和排除，我们可以用静态分析工具检测出来哪些模块没有被调用过。比如，在引用工具库的时候，工程中往往只用到了其中一部分组件或者接口，但是有可能会将其代码完整的加载进来。未被调用的模块代码永远不会被执行，也就成了死代码。通过静态分析可以在打包的时候去掉这些未曾使用过的模块，以减小打包资源体积。

  + 模块变量类型检查，JavaScript属于动态类型语言，不会在代码执行前检查类型错误（比如对一个字符串类型的值进行函数调用）。ES6 Module的静态模块结构有助于确保模块之间传递的值或者接口类型是正确的。典型的应用场景就是我们在vuex或者redux中使用的actionTypes，我们声明常量放在单独的一个文件中进行管理就是利用了ES6 Module的静态模块结构。

  + 编译器优化，在CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而ES6 Module支持导入变量，减少引用层级，程序的效率更高


### 值拷贝与动态映射

在导入一个模块的时候，对于CommonJS来说，获取的是一份导出值的拷贝，而在ES6 Module中则是指的动态映射，并且这个映射是只读的。

上面的话直接理解起来可能比较困难，首先我们来看一个例子，了解一下什么是CommonJS 中的值拷贝。
```js
// calculator.js 
var count = 0;
module.exports = {
  count:count,
  add: function(a,b){
    count += 1;
    return a+b;
  }
}
// index.js
var count = require('./calculator.js').count;
var add = require('./calculator.js').add

console.log(count) // 0 (这里的count 是对calculator.js 中的count值拷贝)
add(2,3)
console.log(count) // 0 calculator.js中变量值的改变不会对这里的拷贝值造成影响)

count += 1

console.log(count) // 1 (拷贝的值可以更改)
```

index.js 中的count 是对 calculator.js中count的一份值拷贝，因此在调用add函数时候，虽然更改了原本calculator.js中的值，但是并不会对index.js 中导入时候创建的副本造成影响。

另一方面，在CommonJS 中允许对导入的值进行更改，我们可以在index.js更改count和add 将其赋予新值，同样，由于是值的拷贝，这些操作不会影响 calculator.js本身。

下面我们使用ES6 Module 将上面的例子进行改写：
```js
// calculator.js 
let count = 0;
const add = function(a,b){
  count += 1;
  return a+b;
}
export {count,add}

// index.js

import {count,add} from './calculator.js'
console.log(count) // 0 (对ccalculator.js中的count值的映射)

add(2,3)

console.log(count) // 1(实时反映calculator.js中count值的变化)
// count += 1 ; // 不可更改，会抛出异常 SymtaxError: 'count' is read-only
```

上面的例子展示了ES6 Module 中导入的变量其实是对原有值的动态映射。index.js 中的count 值是对calculator.js 中的count值的实时反映，当我们通过add 函数更改了calculator.js 中的count值时候，index.js 中的count值也随之变化。

我们不可以对ES6 Module 导入的变量进行更改，可以将这种映射关系理解为一面镜子，从镜子里面我们可以实时观察到原有的事务，但是并不可以操纵镜子中的影像。

### 循环依赖
循环依赖是指模块A依赖于模块B，同时模块B依赖于模块A，比如下面这个例子：
```js
// a.js
import {foo} from './b.js';
foo()

// b.js

import {bar} from './a.js'
bar()
```

一般来说，工程中应该尽量避免循环依赖的产生，因为从软件设计的角度来说，单向的依赖关系更加清晰，而循环依赖则会带来一定的复杂度。而在实际开发中，循环依赖有时候会在我们不经意间产生，因为当工程的复杂度上升到足够的规模时，就容易出现隐藏的循环依赖关系。

简单来说，A和B 两个模块之间是否存在直接的循环依赖关系是很容易被发现的，但实际情况往往是 A依赖于B B 依赖于C，C 依赖于D 最后绕了一圈，D又依赖于A，当中间的模块太多时候就很难发现A 和 B 之间存在着隐式的循环依赖。

因此，如何处理 循环依赖是开发者必须面要面对的问题，我们首先看一下CommonJS 中循环依赖的例子。
```js
// foo.js
const bar = require('./bar.js')
console.log('value of bar:',bar)
module.exports = "This is foo.js"

// bar.js
const foo = require('./foo.js')
console.log("value of foo:",foo)
module.exports = "This is bar.js"

// index.js
require('./foo.js')
```
在这里，index.js 是执行的入口，它加载了 foo.js foo.js 和bar.js 之间存在循环依赖。让我们观察foo.jshe bar.js 中的代码，理想状态下我们希望二者能够导入正确的值，并在控制台上输出：

```js
value of foo: This is foo.js
value of bar: This is bar.js
```
而当我们运行上面的代码时候，实际输出的却是：
```js
value of foo: {}
value of bar: This is bar.js
```
