模块化之于程序，就如同细胞之于生命体，是具有特定功能的组成单元，不同的模块负责不同的工作，它们以某种方式联系在一起，共同保证程序的正常运转。本文将包含以下几个部分：
 + 1 不同的模块标准以及它们之间的区别；
 + 2 如何编写模块
 + 3 模块打包的原理

随着`JavaScript`的发展，社区中产生了很多的模块标准，在认识这些标准的同事，也要了解背后的思想。例如，它为什么会有这个特性，或者为什么要这样去实现，这对于我们自己编写模块也有所帮助。

## `CommonJS`
`CommonJS` 是由`JavaScript`社区于 2009年提出的包含模块、文件、IO、控制台在内的一系列标准。在`Node.js`js的实现中采用了`CommonJS`标准的一部分，并在其基础上进行了一些调整，我们所说的`CommonJS`模块和`Node.js`.js中的实现并不完全一样，现在一般谈到`CommonJS`其实是`Node.js`的版本，而非它的原始定义。

`CommonJS`最初只为服务器设计，直到 `Browserify` -- 一个运行在`Node.js`环境下的模块打包工具，它可以将 `CommonJS`模块打包为浏览器可以单独运行的单个文件。这意味着客户端的代码也可以遵循`CommonJS`标准来编写。

不仅如此，借助`Node.js`的包管理器，npm开发者还可以获取他人的代码库，或者把自己的代码发布上去供他人使用，这种可以共享的传播的方式使的`CommonJS`在前端开发中逐渐流行起来。

### 模块
`CommonJS` 中规定每一个文件是一个模块。将一个`JavaScript`文件直接通过script标签插入页面中与封装成`CommonJS`模块最大的不同在于，前者的顶层作用域是全局作用域，在进行变量声明时会污染全局作用域；而后者会形成一个属于模块自身的作用域，所有的变量以及函数只有自己能够访问，对外是不可见的：
```js
// calculator.js
var name = 'calculater.js';

// index.js
var name = 'index.js';
require('./calculater.js');
console.log(name); // index.js
```
这里有两个文件，在index.js 中我们通过 CommonJS 的require函数加载 calculater.js运行之后控制台结果是 'index.js'，这说明 calculater.js中的变量声明并不会影响 index.js 可见每一个模块是拥有各自作用域的。

### 导出
导出是一个模块向外暴露自身的唯一方式。在CommonJS中，通过module.exports可以导出模块中的内容，如：
```js
module.exports = {
  name:'calculater',
  add:function(a,b) {
    retturn a+b;
  }
};
```
CommonJS 模块内部会有一个module对象用于存放当前模块信息，可以理解成在每一个模块的最开始定义了以下对象：
```js
var module = {...};
// 模块自身的逻辑
module.exports = {...};
```
module.exports 用来指定该模块对外暴露哪些内容，在上面的代码中我们导出了一个对象，包含name 和add 两个属性，为了书写方便，
CommonJS也支持另一种简化的导出方式——直接使用exports.
```js
exports.name = 'calculater';
exports.add = function(a,b) {
  return a+b;
};
```
在实现效果上，这段代码和上面的module.exports没有任何不同，其内在机制是将exports 指向了 module.exports，而module.exports在初始化的时候是一个空的对象，我们可以简单的理解为CommonJS在每个模块的首部默认添加了以下代码：
```js
var module = {
  exports:{}
};

var exports = module.exports
```

因此，为exports.add 赋值相当于  module.exports 对象上添加一个属性。

在使用 exports 时候要注意一个问题，即不要直接给exports 赋值，否则会导致失效。如：

```js
exports = {
  name:'calculater'
}
```

上面的代码中，由于对exports进行了赋值操作，使其指向了新的对象，module.exports却仍然是原来的空对象，因此name属性并不会被导出。

另一个在导出时候容易犯的错误是不恰当的把module.exports于exports混用。

```js
exports.add = function(a,b){
  return a+b;
};

module.exports = {
  name:'calculater'
}
```
上面的代码先通过exports导出了add 属性，然后将module.exports重新赋值为另一个对象。这会导致原本拥有add属性的对象丢失了，最后导出的只有name。

另外 要注意导出语句不代表模块的末尾，在module.exports 或者 exports 后面的代码依旧照常执行。比如下面的console会在控制台上打出 'end'：

```js
module.exports = {
  name:'calculater',
};

console.log('end')
```
在实际开发中，为了提高可读性，不建议采取上面的写法，而是应该将 module.exports以及export语句放在模块的末尾。

### 导入

在CommonJS中使用require进行模块导入。如：
```js
// calculator.js

module.exports = {
  add: function(a,b){
    return a+b;
  };
};

// index.js
const calculator = require('./calculator.js');
const sum = calculator.add(2,3);
console.log(sum) // 5 
```

我们在index.js 中导入了calculator模块，并调用了它的add 函数。

当我们require一个模块的时候会有两种情况：
  + require的模块是第一次被加载。这时候会首先执行这个模块，然后导出内容。
  + require的模块被曾经加载过，这时候该模块的代码不会再次执行，而是直接导出上次执行后的结果。

请看下面的例子：
```js
// calculator.js
console.log('running calculator.js');
module.exports = {
  name:'calculator',
  add: function(a,b){
    return a+b;
  };
}
// index.js
const add = require('./calculator.js').add;
const sum = add(2,3);
console.log('sum:',sum);
const moduleName = require('./calculator.js').name;
console.log(name)
```
控制台输出如下结果：

```js
running calculator.js
sum:5
end
```
从结果可以看出，尽管我们有两个地方都调用了require('./calculator.js') 但是其实内部代码只执行了一遍。

我们前面提到，模块会有一个`module`对象存放其信息，这个对象中有一个属性loaded 用于记录该模块是否被加载过。他的值默认为false，当模块第一次被加载和执行过后置为true，后面再次加载时候回检查module。loaded 为true 则不会再次执行模块代码。

有时候我们加载一个模块，不需要获取其导出的内容，只是想想要通过执行它而产生某种作用，比如把它的接口挂载在全局对象上，此时直接使用require即可。

```js
require('./task.js')
```

另外，require 函数可以接收表达式，借助这个特性我们可以动态的指定模块的加载路径。

```js
const moduleName = ['foo.js','bar.js'];
moduleNameforEach(name => {
  require('./'+name)
})
```

## ES6 Module
在JavaScript被设计之初，原本并没有包含模块的概念，基于越来越多的工程需求，为了使用模块化进行开发JavaScript社区中出现了多种模块的标准，一直到2015年6月，TC39标准委员会正式发布了ES6 从此JavaScript语言才具有了模块这一个特性。

### 模块

请看下面的例子,我们将前面的 calculator.js 和 index.js 使用ES6方式进行了改写。
```js
// calculator.js
export defaut {
  name: 'calculator',
  add:function() {
    return a+b
  }
}

// index.js
import calculator from './calculator.js';
const sum =  calculator.add(2,3);
console.log(sum); // 5
```

ES6 Module 也是将每一个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。import 和 export 也作为保留关键字在ES6版本中加了进来，（CommonJS中module并不属于关键字）。

ES6 Module 会自动的采用严格模式，这在ES5 中是一个可选项，以前我们在文件开始添加 'use strict' 来控制是否开启严格模式，

### 导出

在ES6 Module 中使用export 命令来导出模块。export 有两种模式：
  + 命名导出
  + 默认导出
一个模块可以有多个命名导出，它有两种不同的写法：
```js
// 写法1
export const name = 'calculator';
export const add = function(a,b) {
  return a+b
}

// 写法2
const name = 'calculator';
const add = function(a,b) {
  return a+b
}
export { name, add}
```

第一种写法是将变量的声明和导出写在同一行；第二种则是先进行变量声明，然后再用同一个export语句导出，两种写法的效果是一样的。

在使用命名导出的时候，可以使用as关键字对变量重命名。如：
```js
const name = 'calculator'
const add = function(a,b) {return a+b};
export {
  name,
  add as getsum // 在导入时即为name 和 getSum
};
```
与命名导出不同，模块的默认导出只能由一个： 如：
```js
export default {
  name:'calculator',
  add: function(a,b) {
    return a+b
  }
}
```
我们可以将export default 理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。

