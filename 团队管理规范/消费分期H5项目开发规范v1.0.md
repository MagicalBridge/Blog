## 消费分期H5技术栈：
`React`全家桶,UI层面使用的是阿里开源的`antd`组件库。
`React`版本

## 基本规范
  * 1、每个文件只写一个模块，也可以称之为一个组件,通俗点说，每个组件中只能包含一个组件实例
  * 2、使用JSX语法编写代码，保持风格统一。
  * 3、不要使用 `React.createElement`创建实例,除非从一个非JSX的文件中初始化你的app

## 创建模块
  Class vs React.createClass vs stateless
  * 1、如果编写的模块有内部状态(`state`)或者是`refs`, 推荐使用 `class extends React.Component` 而不是 `React.createClass`
  ```jsx
    // bad
    const Listing = React.createClass({
      // ...
      render() {
        return <div>{this.state.hello}</div>;
      }
    });

    // good
    class Listing extends React.Component {
      // ...
      render() {
        return <div>{this.state.hello}</div>;
      }
    }
  ```
  * 2、如果你的模块没有状态（所有状态从父组件传入）或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类:
  ```jsx
    // bad (对于无状态组件，不推荐使用类的写法)
    class Listing extends React.Component {
      render() {
        return <div>{this.props.hello}</div>;
      }
    }

    // bad (不建议依赖函数名推断)
    const Listing = ({ hello }) => (
      <div>{hello}</div>
    );

    // good (直接使用函数声明的方式)
    function Listing({ hello }) {
      return <div>{hello}</div>;
    }
  ```
## Mixins
  [不要使用 mixins](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)
  在大多数情况下Mixins可以被更好的方法替代，如：组件化，高阶组件等。

## 命名规范  
  * 1、扩展名,`React`组件的扩展名使用`.jsx`扩展名。
  * 2、使用驼峰命名：`mallRebate`第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母
  * 3、引用命名: `React`模块名使用首字母大写的形式，实例使用骆驼式命名。
  ```jsx
    // 组件引入 首字母开头大写
    // bad 
    import reservationCard from './ReservationCard';
    // good
    import ReservationCard from './ReservationCard';

    // 将组件的实例赋值时候使用驼峰命名
    // bad
    const ReservationItem = <ReservationCard />;

    // good
    const reservationItem = <ReservationCard />;
  ```
  * 模块命名: 模块使用当前文件名一样的名称. 比如`mallRebate.jsx`应该放在`mallRebate`文件夹内，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称
  
  ```js
    // bad
    import Footer from './Footer/index';

    // good
    import Footer from './Footer';
  ```
  * 属性命名: 避免使用DOM相关的属性来用作其他的用途。
  > 为什么？对于style 和 className这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。
  ```jsx
    // 传递给组件 不要使用style 和 className这种关键字，
    // bad
    <MyComponent style="fancy" />

    // good
    <MyComponent variant="fancy" />
  ```

## 声明模块
  * 1、不要使用`displayName`来命名React模块，而是使用引用来命名模块， 如`class`名称。
  ```jsx
    // 使用 直接声明变量的方式命名组件名称
    // bad
    export default React.createClass({
      displayName: 'ReservationCard',
      // stuff goes here
    })

    // good
    export default class ReservationCard extends React.Component {
    }
  ```

## 代码对齐
  * 遵循以下的JSX语法缩进/格式.
  ```jsx
  // bad
  <Foo superLongParam="bar"
    anotherSuperLongParam="baz" />

  // good, 有多行属性的话, 新建一行关闭标签
  <Foo
    superLongParam="bar"
    anotherSuperLongParam="baz"
  />

  // 若能在一行中显示, 直接写成一行
  <Foo bar="bar" />

  // 子元素按照常规方式缩进
  <Foo
    superLongParam="bar"
    anotherSuperLongParam="baz"
  >
    <Quux />
  </Foo>
  ```
## 单引号还是双引号
  * 对于JSX属性值总是使用双引号("), 其他均使用单引号(')
  >为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定.
  ```jsx
    // bad
    <Foo bar='bar' />

    // good
    <Foo bar="bar" />

    // bad
    <Foo style={{ left: "20px" }} />

    // good
    <Foo style={{ left: '20px' }} />
  ```
## 空格
  * 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行。
  ```jsx
    // bad
    <Foo/>

    // very bad
    <Foo                 />

    // bad
    <Foo
    />

    // good
    <Foo />
  ```
  * 不要在JSX {} 引用括号里两边加空格.
  ```jsx
    // bad
    <Foo bar={ baz } />

    // good
    <Foo bar={baz} />
  ```

## Props 属性
  * JSX属性名使用骆驼式风格camelCase.
  ```jsx
    // bad
    <Foo
      UserName="hello"
      phone_number={12345678}
    />

    // good
    <Foo
      userName="hello"
      phoneNumber={12345678}
    />
  ```
  * 如果属性值为 true, 可以直接省略
  ```jsx
    // bad
    <Foo
      hidden={true}
    />

    // good
    <Foo
      hidden
    />

    // good
    <Foo hidden />
  ```
  * <img> 标签总是添加 alt 属性
  ```jsx
  // bad
  <img src="hello.jpg" />

  // good
  <img src="hello.jpg" alt="Me waving hello" />

  // good
  <img src="hello.jpg" alt="" />
  ```
  * 避免使用数组的index来作为属性key的值，推荐使用唯一ID.
  ```jsx
  // bad
  {todos.map((todo, index) =>
    <Todo
      {...todo}
      key={index}
    />
  )}

  // good
  {todos.map(todo => (
    <Todo
      {...todo}
      key={todo.id}
    />
  ))}
  ```

  * 对于所有非必须的属性，总是手动去定义`defaultProps`属性.
  > 为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查.

  ```jsx
    // bad
    function SFC({ foo, bar, children }) {
      return <div>{foo}{bar}{children}</div>;
    }
    SFC.propTypes = {
      foo: PropTypes.number.isRequired,
      bar: PropTypes.string,
      children: PropTypes.node,
    };

    // good
    function SFC({ foo, bar, children }) {
      return <div>{foo}{bar}{children}</div>;
    }
    SFC.propTypes = {
      foo: PropTypes.number.isRequired,
      bar: PropTypes.string,
      children: PropTypes.node,
    };
    SFC.defaultProps = {
      bar: '',
      children: null,
    };  
  ```
## Refs
  * 总是在Refs里使用回调函数.
  ```jsx
  // bad
  <Foo
    ref="myRef"
  />

  // good
  <Foo
    ref={(ref) => { this.myRef = ref; }}
  />
  ```

## 括号
  * 将多行的JSX标签写在 ()里
  ```jsx
  // bad
  render() {
    return <MyComponent className="long body" foo="bar">
            <MyChild />
          </MyComponent>;
  }

  // good
  render() {
    return (
      <MyComponent className="long body" foo="bar">
        <MyChild />
      </MyComponent>
    );
  }

  // good, 单行可以不需要
  render() {
    const body = <div>hello</div>;
    return <MyComponent>{body}</MyComponent>;
  }
  ```
## Tags 标签
  * 对于没有子元素的标签来说总是自己关闭标签
  ```jsx
  // bad
  <Foo className="stuff"></Foo>

  // good
  <Foo className="stuff" />
  ```
  * 如果模块有多行的属性， 关闭标签时新建一行
  ```jsx
  // bad
  <Foo
    bar="bar"
    baz="baz" />

  // good
  <Foo
    bar="bar"
    baz="baz"
  />
  ```
## 函数
  * 使用箭头函数来获取本地变量.
  ```jsx
    function ItemList(props) {
      return (
        <ul>
          {props.items.map((item, index) => (
            <Item
              key={item.key}
              onClick={() => doSomethingWith(item.name, index)}
            />
          ))}
        </ul>
      );
    }
  ```
  * 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去
  > 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源.
  ```jsx
    // bad
    class extends React.Component {
      onClickDiv() {
        // do stuff
      }

      render() {
        return <div onClick={this.onClickDiv.bind(this)} />;
      }
    }

    // good
    class extends React.Component {
      constructor(props) {
        super(props);

        this.onClickDiv = this.onClickDiv.bind(this);
      }

      onClickDiv() {
        // do stuff
      }

      render() {
        return <div onClick={this.onClickDiv} />;
      }
    }
  ```
  * 在React模块中，不要给所谓的私有函数添加 _ 前缀，本质上它并不是私有的.
  > 为什么？_ 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue #1024, 和 #490 。

  ```jsx
    // bad
    React.createClass({
      _onClickSubmit() {
        // do stuff
      },

      // other stuff
    });

    // good
    class extends React.Component {
      onClickSubmit() {
        // do stuff
      }

      // other stuff
    }
  ```
  * 在 render 方法中总是确保 return 返回值.
  ```jsx  
  // bad
  render() {
    (<div />);
  }

  // good
  render() {
    return (<div />);
  }
  ```
## React 模块生命周期
  * class extends React.Component 的生命周期函数:
  * 1、可选的 static 方法
  * 2、constructor 构造函数
  * 3、getChildContext 获取子元素内容
  * 4、componentWillMount 模块渲染前
  * 5、componentDidMount 模块渲染后
  * 6、componentWillReceiveProps 模块将接受新的数据
  * 7、shouldComponentUpdate 判断模块需不需要重新渲染
  * 8、componentWillUpdate 上面的方法返回 true， 模块将重新渲染
  * 9、componentDidUpdate 模块渲染结束
  * 19、componentWillUnmount 模块将从DOM中清除, 做一些清理任务
  * 20、点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription()
