###【题目】
实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。
###【要求】
1.pop、push、getMin操作的时间复杂度都是O（1）。
2.设计的栈类型可以使用现成的栈结构。

### 【解析】

压入数据的规则：
  假设当前的数据为newNum 先将其压入stackData 然后判断 stackMin 是否是空的
  如果为空的，则newNum也压入 stackMin
  如果不为空，则比较newNum 和stackMin 的栈顶元素中哪一个更加小小。
  如果newNum 更小或者两者相等，则将newNum也压入stackMin
  如果stackMin 中栈顶元素小，则stackMin 不压入任何内容
  
  1  -> 同步压入     1
  2  -> 不压入      无
  1  -> 同步压入     1
  5  -> 不压入      无
  4  -> 不压入      无
  3  -> 同步压入     3
  stackData         stackMin
  
弹出数据的规则:
  先在stackData 中弹出栈顶元素，记为value 然后比较当前的 stackMin 的栈顶元素和value
  哪一个更小。
  
  通过上文提到的压入规则可以知道，stackMin 中存在的元素是从栈底到栈顶逐渐变小的，
  stackmin栈顶元素即是stackmin 中的最小值，也是当前stackdata栈的最小值。所以不会
  出现value比stackmin的栈顶元素更加小的情况，value 只能大于或者等于 stackmin的栈顶元素
  
  当value 等于stackmin 的栈顶元素的时候，stackmin 弹出栈顶元素 当value 大于stackmin的栈顶元素的
  时候stackmin不弹出栈顶元素 返回value
  
查询当前栈中的最小的值操作:
  stackmin的栈顶始终存放的是 stackdata中的最小值。
  直接返回就好。


```java
public class getMinStck {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;
     
    public getMinStck() {
        this.stackData = new Stack<Integer>();
        this.stackMin = new Stack<Integer>();
    }

     
    public void push(int newNum) {
        // 如果当前的stackMin 是空的情况下
        if (this.stackMin.isEmpty()) {
            // 直接将 新的值 放进去
            this.stackMin.push(newNum);
            // 如果这个新添加的数值小于或者等于 stackMin 的栈顶元素
        } else if (newNum <= this.getmin()) {
            // 同样的也可以添加进去
            this.stackMin.push(newNum);
        }
        // 这个添加操作对于 stackData 是必须的
        this.stackData.push(newNum);
    }

    public int pop() {
        // 边界问题，如果stackData 数据是空的 抛出异常
        if (this.stackData.isEmpty()) {
            throw new RuntimeException("Your stack is empty");
        }
        // 记录 stackData 弹出的值
        int value = this.stackData.pop();
        // 如果pop的值等于 stackmin  栈顶的值 stackmin 也弹出来
        if (value == this.getmin()) {
          this.stackMin.pop();
        }
        return value;
    }

    public int getmin() {
        //边界问题的处理 如果stackmin 是空的 直接抛出异常
        if (this.stackMin.isEmpty()) {
            throw new RuntimeException("Your stack is empty");
        }
        // 调用peek 方法弹出数据
        return this.stackMin.peek();
    }
}
```
