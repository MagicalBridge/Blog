## 方法: 初等数学

思路

我们使用变量来跟踪进位，并从包含最低有效的表头开始模拟逐位相加的过程。

算法

就像你在纸上计算两个数字的和那样，我们首先从最低位也就是列表 l1 和 l2的表头开始相加，由于每位数字都应当处于0-9的范围内，我们计算两个数字的和时候可能出现"溢出",例如 5+7 = 12 在这种情况下，我们会将当前位的数值设置为2，并将进位 carry = 1 带入下一次迭代，进位carry必定是0或1，这是因为两个数字相加可能出现的最大和是 9+9+1 = 19。

伪代码如下:

* 将当前的节点初始化为返回列表的哑结点
* 将进位carry初始化为0
* 将p 和 q 分别初始化为链表l1 和 l2的头部。
* 遍历链表 l1 和 l2 直到达到他们的尾部
  * 将x设置为节点p的值,如果p已经到达l1的末尾，则将其值设置为0。
  * 将y设置为节点q的值，如果q已经到达了l2的末尾，则将其值设置为0。
  * 设置sum = x+y+carry
  * 更新进位的值 carry = carry/10
  * 创建一个数值为 sum mod 10 的新节点，并将其设置为当前节点的下一个节点，然后将当前节点前进到下一个节点。
  * 同时 将 p 和 前进到下一个节点。

* 检查carry = 1 是否成立，如果成立，则向返回链表追加一个含有数字1的新的节点。
* 返回哑结点的下一个节点

请注意：我们使用哑结点来简化代码，如果没有哑结点，则必须要编写额外的条件语句来初始化表头的值。

请特别注意以下情况:
测试用例                    说明
l1 = [0,1] l2 = [0,1,2]    当一个链表比另一个链表长时。
l1 = [],   l2 = [0,1]      当一个链表为空时，即出现了空链表的情况
l1 = [9,9] l2 = [1]        求和运算最后可能出现额外的进制，这一点容易被遗忘。

```js
/**
 * 1、问题1: 我没有写temp 变量
 * 2、问题2：使用while循环我是知道的，但是，while循环的条件没有想清楚
 * 3、问题3：在计算sum的时候, 使用的三目运算符, 判断的的l1 或者 l2 而不是 他们的val
 * 4、问题4、在循环完毕之后，carry 还有可能存在,这个时候需要在链表后面添加 carry。
 */
var addTwoNumbers = (l1, l2) => {
  // 这个节点有许多名字：虚拟头结点、哨兵节点、哑结点。反正无论叫什么，作用都是为了简化代码的操作
  // 开辟了一个虚拟头结点，需要用一个变量来承接这个节点，这个节点本身是不能动的。
  let dummyHead = new ListNode(-1);
  // 这个虚拟头结点是不能够
  let temp = dummyHead;
  let carry = 0;
  let sum = 0;
  // 这里使用while循环
  while (l1 || l2) {
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
    temp.next = new ListNode(sum % 10); // 取余数操作
    temp = temp.next;
    // 进位应该如何计算,这里其实很巧妙因为两位数字相加的最大是加上进制的最大是19因此
    // 如果两个数相加是两位数那么,进制就是1,如果两数相加是个位数进制就是0。
    carry = sum >= 10 ? 1 : 0
    // 计算完两个数相加之后, 将传入的两个链表的指针向后移动
    l1 && (l1 = l1.next);
    l2 && (l2 = l2.next);
  }
  // 循环结束之后，很可能还存在一个进制，这个时候需要补上这个数字
  carry && (temp.next = new ListNode(carry));
  return dummyHead.next;
}
```






