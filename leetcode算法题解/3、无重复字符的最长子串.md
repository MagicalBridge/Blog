## 解法一: 维护数组

解题思路： 使用一个数组来维护滑动窗口

遍历字符串，判断字符串是否在滑动窗口数组里面
* 不在则push进数组
* 在则删除滑动窗口数组里面相同的字符前的字符，然后将当前字符push进去
* 然后将max更新为当前最长的子串的长度

遍历完毕返回max即可:
![算法图示](https://pic.leetcode-cn.com/202ea5bd4d4ba4a21afafdf52a9ea2556ba6265c1576840f09ace50aafab095c.png)

代码实现:
```js
var lengthOfLongestSubstring = function(s) {
  let arr = [];
  let max = 0;
  for(let i = 0; i < s.length; i++) {
    // 这里使用到了Array.prototype.indexOf 方法
    let index = arr.indexOf(s[i]);
    // !== -1 说明找到了
    if(index !== -1) {
      // 这里使用到了arr.splice方法 splice 方法 接收三个参数 第一个参数是开始的位置
      // 第二个参数 是删除元素的个数，第三个参数是可选 需要替换的元素。
      // 这里使用了前两个参数, index+1 因为index 是从0开始的，且我们要删除当前index这个位置的元素
      arr.splice(0,index + 1);
    }
    arr.push(s.charAt(i));
    max = Math.max(arr.length,.max)
  }
  return max
}
``` 

## 解法二：维护下标

解题思路：使用下标来维护滑动窗口

代码实现:

```js
var lengthOfLongestSubstring = function(s) {
  let index = 0;
  let max = 0;

  for(let i = 0; j = 0; j < s.length; j++ ) {
    index = s.subString(i,j).indexOf(s[j]);
    if(index !== -1) {
      i = i + index + 1;
    }
    max = Math.max(max, j - i + 1);
  }
  return max
}
```

## 解法三: 优化的Map

解题思路:
使用map来存储当前已经遍历过的字符，key为字符，value 为下标。
使用i来标记无无重复子串开始下标，j 为当前遍历的字符下标。

遍历字符串，判断当前字符串是否已经在map中存在，存在则更新无重复子串的下标 i 为相同字符串的下一个位置，此时从i到j为最新的无重复的子串，更新 max 当前字符与下标放入map 中，最后返回 max 即可

代码实现：

```js
var lengthOfLongestSubstring = function(s) {
  let map = new Map()
  let max = 0;

  for(let i = 0; j = 0; j < s.lenght; j++) {
    if(map.has(s[j])) {
      i = Math.max(map.get(s[j])+1, i);
    }
    max = Math.max(max, j - i + 1);
    map.set(s[j], j)
  }
  return max
}
```
