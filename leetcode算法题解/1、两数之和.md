### 方法一: 暴力法

暴力法很简单，遍历每一个元素x, 并查找是否存在一个值与 target-x 相等的元素。
```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
let twoSum = function(nums, target) {
  for(let i = 0; i < nums.length; i++) {
    for(let j = 0; i < nums.length; j++) {
      if(nums[i] === target - nums[j]) {
        return [i,j]
      }
    }
  }
  throw new Error('No two sum solution')
}
```
复杂度分析:
  * 时间复杂度O(n^2^)对于每个元素，我们通过遍历数组的其余部分来寻找它对应的目标元素，这将耗费O(n)的时间。因此时间复杂度是O(n^2^)。
  * 空间复杂度: O(1)

### 方法二: 两遍哈希表

为了对运行的时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？ 哈希表。

通过以空间换取速度的方式，我们可以将查找的时间从 O(n) 降低到 O(1)。哈希表正是为此目的构建的，它支持以近似恒定的时间进行快速查找。我们用'近似'来描述，是因为一旦出现冲突，查找用的时间可能会退化到O(n),但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销O(1)。

一个简单的实现使用了两次迭代，在第一次的迭代中，我们将每个元素的值和它的索引添加到表中，然后，在第二次的迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中，**注意，该目标元素不能是nums[i]本身!**。
```js
let twoSum = function (nums, target) {
  // 边界条件: 数组的长度小于2 的时候已经不符合题目要求
  if (nums.length < 2 || nums === undefined) {
    return nums
  }
  let resArr = []; // 创建结果数组
  // 唯手熟尔 使用map这种映射，映射的是 数字是啥和数字出现的位置
  // 使用map 建立映射关系
  let map = new Map();
  for (let i = 0; i < nums.length; i++) {
    // 创建映射关系
    map.set(nums[i], i);
  }

  // 第二次遍历, 每遍历一个数字就在map中寻找看是否存在
  for (let i = 0; i < nums.length; i++) {
    // 另外一个数字，是目标的值减去当前的值
    let anotherNumber = target - nums[i]
    // 这个判断是 map中包含这个值,且不是当前这个值
    if (map.has(anotherNumber) && map.get(anotherNumber) !== i) {
      // push 进去的是索引
      resArr.push(i);
      resArr.push(map.get(anotherNumber));
      break;
    }
  }
  return resArr;
}
```
复杂度分析:
  * 时间复杂度: O(n). 我们把包含n个元素的列表遍历两次，由于哈希表将查找的时间缩短到了O(1),所以时间复杂度为O(n)。
  * 空间复杂度: O(n). 所需要的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 


### 方法三: 一遍哈希表

事实证明，我们可以一次完成，在进行迭代并将元素插入到表的同时，我们还会回过头来检查表中是否存在当前元素所对应的目标元素，如果它存在，那我们已经找到了对应解，并立即将其返回。

复杂度分析:
  * 时间复杂度: O(n). 我们只遍历了一遍包含n个元素的列表一次。 在表中进行的每次检查只花费O(1)的时间。
  * 空间复杂度: O(n). 所需要的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。
```js
let twoSum = function (nums, target) {
  let map = new Map();
  let resArr = [];
  for (let i = 0; i < nums.length; i++) {
    // 因为是一次for循环 且map 中不能存在两个相同的key
    // 其实是一个边放数字边判断的过程
    if (map.has(target - nums[i])) {
      resArr[0] = i;
      resArr[1] = map.get(target - nums[i])
      break;
    }
    map.set(nums[i], i)
  }
  return resArr
}
```