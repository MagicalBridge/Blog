### 方法一: 暴力法

暴力法很简单，遍历每一个元素x, 并查找是否存在一个值与 target-x 相等的元素。
```js

```
复杂度分析:
  * 时间复杂度O(n^2^)对于每个元素，我们通过遍历数组的其余部分来寻找它对应的目标元素，这将耗费O(n)的时间。因此时间复杂度是O(n^2^)。
  * 空间复杂度: O(1)

### 方法二: 两遍哈希表

为了对运行的时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？ 哈希表。

通过以空间换取速度的方式，我们可以将查找的时间从 O(n) 降低到 O(1)。哈希表正是为此目的构建的，它支持以近似恒定的时间进行快速查找。我们用'近似'来描述，是因为一旦出现冲突，查找用的时间可能会退化到O(n),但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销O(1)。

一个简单的实现使用了两次迭代，在第一次的迭代中，我们将每个元素的值和它的索引添加到表中，然后，在第二次的迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中，**注意，该目标元素不能是nums[i]本身!**。
```js
```
复杂度分析:
  * 时间复杂度: O(n). 我们把包含n个元素的列表遍历两次，由于哈希表将查找的时间缩短到了O(1),所以时间复杂度为O(n)。
  * 空间复杂度: O(n). 所需要的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 


### 方法三: 一遍哈希表

事实证明，我们可以一次完成，在进行迭代并将元素插入到表的同时，我们还会回过头来检查表中是否存在当前元素所对应的目标元素，如果它存在，那我们已经找到了对应解，并立即将其返回。

复杂度分析:
  * 时间复杂度: O(n). 我们只遍历了一遍包含n个元素的列表一次。 在表中进行的每次检查只花费O(1)的时间。
  * 空间复杂度: O(n). 所需要的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。
```js
```