# 第 10 天

## 1.深刻理解基本数据类型，下面代码会输出什么

```go
func main() {
	a := 10
	b := 20.1
  fmt.Println(a + b)
}
```

## 解析：
在Go语言中，不同类型的变量不能直接进行算术运算。在上面的代码中，a 是一个整数类型（int），而 b 是一个浮点数类型（float64）。直接将它们相加会导致编译错误。

Go语言是一种静态类型语言，这意味着变量的类型在编译时就已经确定，并且在运行时不能改变。当你尝试将不同类型的变量相加时，编译器会检测到类型不匹配，并拒绝编译代码。

为了解决这个问题，你需要将其中一个变量转换为另一个变量的类型，或者使用相同类型的变量进行运算。例如，你可以将 a 转换为 float64 类型，然后再与 b 相加：

```go
package main

import "fmt"

func main() {
	a := 10
	b := 20.1
	fmt.Println(float64(a) + b)
}
```

在这个修改后的代码中，a 被转换为 float64 类型，然后与 b 相加。这样，a 和 b 都是 float64 类型，因此可以进行加法运算。

## 2.深刻理解切片，下面这段代码输出什么？

```go
package main

import "fmt"

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[3:4:4]
	fmt.Println(t[0])
}
```

## 解析：
这段代码定义了一个包含5个整数的数组 a，并使用切片操作 a[3:4:4] 创建了一个新的切片 t。然后，代码打印了切片 t 的第一个元素。

让我们逐步分析代码：

a := [5]int{1, 2, 3, 4, 5}: 这行代码定义了一个包含5个整数的数组 a，并初始化了数组的元素。

t := a[3:4:4]: 这行代码使用切片操作 a[3:4:4] 创建了一个新的切片 t。切片操作的语法是 [low:high:max]，其中 low 是切片的起始索引，high 是切片的结束索引（不包含），max 是切片的容量。在这个例子中，low 是 3，high 是 4，max 也是 4。这意味着切片 t 包含了数组 a 中索引为 3 的元素，并且切片的容量是 1。（切片 t 的容量是 max - low ，即 4 - 3 = 1 。这意味着切片 t 的容量是1）

fmt.Println(t[0]): 这行代码打印了切片 t 的第一个元素。由于切片 t 只包含一个元素，即数组 a 中索引为 3 的元素，所以这行代码会打印出 4。

因此，这段代码会输出 4。

## 3.深刻理解数组类型，下面这段代码输出什么？

```go
func main() {
	a := [2]int{5,6}
	b := [3]int{5,6}
	if a == b {
		fmt.Println("equal")
	} else {
		fmt.Println("not equal")
	}
}
```
## 解析：
这段Go代码比较了两个数组a和b，其中a的长度为2，b的长度为3。在Go语言中，数组的长度是数组类型的一部分，因此`[2]int`和`[3]int`是不同的类型，不能直接比较。这段代码会导致编译错误，不会输出任何内容。

这段代码会输出编译错误，因为Go语言中数组的长度是数组类型的一部分，[2]int和[3]int是不同的类型，不能直接比较。要比较两个数组，它们的类型必须完全相同。


