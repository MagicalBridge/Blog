# 第 23 天

## 1.下面这段代码输出什么为什么?
```go
func main() {
  s1 := []int{1, 2, 3}
  s2 := s1[1:]
  s2[1] = 4
  fmt.Println(s1)
  s2 = append(s2, 5, 6, 7)
  fmt.Println(s1)
}
```

## 解析：
让我来分析这段代码的输出和原因：

输出结果将会是：
```
[1 2 4]
[1 2 4]
```

让我们逐步分析原因：
1. 第一行输出 `[1 2 4]` 的分析：
   - `s1 := []int{1, 2, 3}` 创建了一个切片 s1，包含元素 [1,2,3]
   - `s2 := s1[1:]` 基于 s1 创建了一个新的切片 s2，从索引 1 开始，所以 s2 包含 [2,3]
   - `s2[1] = 4` 修改 s2 的索引 1 位置的值为 4。由于 s2 和 s1 共享底层数组，这个修改也会影响到 s1
   - 因此第一次打印 s1 时输出 [1,2,4]

2. 第二行输出 `[1 2 4]` 的分析：
   - `s2 = append(s2, 5, 6, 7)` 向 s2 追加三个元素
   - 由于追加操作会导致 s2 的容量不足，Go 会为 s2 重新分配一个新的底层数组
   - 新数组会包含所有元素 [2,4,5,6,7]，但这个操作不会影响原来的 s1
   - 所以第二次打印 s1 时，输出仍然是 [1,2,4]

这个例子很好地展示了 Go 中切片的两个重要特性：
1. 切片共享底层数组时，修改其中一个切片会影响其他切片
2. 当 append 操作导致切片容量不足时，会创建新的底层数组，此时对新切片的修改不会影响原切片