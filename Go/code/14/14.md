# 第 14 天

## 1. 下面代码会输出什么？

```go
func main() {
  str := "hello"
  str[0] = 'x'
  fmt.Println(str)
}
```

## 解析：

这段代码会**编译失败**，并报错： `cannot assign to str[0]`
1. **字符串的不可变性**：
  - 在 Go 语言中，字符串是不可变的（immutable），这意味着字符串的内容不能被修改。
  - `str[0] = 'x'` 试图修改字符串 `str` 的第一个字符，这是不允许的，因此会导致编译错误。

2. **如何修改字符串**：
  - 如果需要修改字符串，可以先将字符串转换为 `[]byte` 或 `[]rune` 切片，修改后再转换回字符串。例如：
  ```go
  func main() {
    str := "hello"
    strBytes := []byte(str)
    strBytes[0] = 'x'
    str = string(strBytes)
    fmt.Println(str) // 输出：xello
  }
  ```
这段代码会编译失败，因为字符串是不可变的，不能直接通过索引修改其内容。

## 2. 下面代码会输出什么？

```go
func incr(p *int) int {
  *p++
  return *p
}

func main() {
  p := 1
  incr(&p)
  fmt.Println(p)
}
```

## 解析：
这段 Go 代码会输出 `2`。

1. **`incr` 函数**：
  - 接受一个指向 `int` 类型的指针 `p`。
  - 通过 `*p++` 将指针 `p` 所指向的值加 1。
  - 返回加 1 后的值。

2. **`main` 函数**：
  - 定义一个整数变量 `p`，初始值为 `1`。
  - 调用 `incr(&p)`，将 `p` 的地址传递给 `incr` 函数。
  - 在 `incr` 函数中，`p` 的值被修改为 `2`。
  - 最后，`fmt.Println(p)` 输出 `p` 的值，此时 `p` 的值已经是 `2`。


## 3.对add()函数调用正确的是？

```go
func add(args ...int) int {
  sum := 0
  for _, arg := range args {
    sum += arg
  }
  return sum
}
```
- A. `add(1, 2)`
- B. `add(1, 3, 7)`
- C. `add([]int{1, 2})`
- D. `add([]int{1, 3, 7}...)`


对于 `add()` 函数的调用，正确的选项是 **A、B 和 D**。

## 解析：
`add(args ...int)` 是一个可变参数函数，它接受任意数量的 `int` 类型参数。`args` 是一个切片（`[]int`），函数会遍历切片中的每个元素并累加它们的值。

### 选项分析：
- **A. `add(1, 2)`**  
  这是正确的调用方式。函数会接收两个参数 `1` 和 `2`，计算结果为 `3`。

- **B. `add(1, 3, 7)`**  
  这也是正确的调用方式。函数会接收三个参数 `1`、`3` 和 `7`，计算结果为 `11`。

- **C. `add([]int{1, 2})`**  
  这是错误的调用方式。`add()` 函数的参数是 `...int`，而不是 `[]int`。直接传递一个切片会导致类型不匹配的错误。

- **D. `add([]int{1, 3, 7}...)`**  
  这是正确的调用方式。`...` 是 Go 中的语法糖，用于将切片展开为可变参数。`[]int{1, 3, 7}...` 会将切片展开为 `1, 3, 7`，相当于 `add(1, 3, 7)`。

- **A、B、D** 是正确的调用方式。
- **C** 是错误的调用方式。
