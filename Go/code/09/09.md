# 第9天：

## 1.深刻理解channel，下面说法正确的是？
A: var ch chan int
B: ch := make(chan int)
C: <- ch 
D: ch <-

## 解析：

从语法层面来看，每个选项的正确性如下：

选项A: var ch chan int
语法正确性: 这行代码在语法上是正确的。它声明了一个名为ch的变量，类型为chan int，即整数类型的channel。但这只是声明，并没有初始化，此时ch的值为nil，不能直接用于发送或接收数据。

选项B: ch := make(chan int)
语法正确性: 这行代码在语法上是正确的。它使用make函数创建了一个整数类型的channel，并将其赋值给变量ch。make函数会初始化channel，使其可以用于发送和接收数据。这是创建channel的正确方式。

选项C: <- ch
语法正确性: 这行代码在语法上是正确的。它表示从channel ch中接收数据。箭头<-的方向指向变量，表示从channel中读取数据并赋值给变量。如果ch中没有数据，接收操作会阻塞，直到有数据可用。

选项D: ch <-
语法正确性: 这行代码在语法上是不正确的。它缺少要发送的数据。正确的发送操作应该是ch <- data，其中data是要发送的整数。

总结
从语法层面来看，选项A、B、C在语法上是正确的，选项D在语法上是不正确的。选项A只是声明了channel但没有初始化，选项C是从channel接收数据的正确操作，选项D缺少要发送的数据。只有选项B使用make函数正确地创建了一个可以用于发送和接收数据的channel。

## 2.下面这段代码会输出什么？

```go
type person struct {
  name string
}

func main() {
  var m map[person]int
  p := person{"张三"}
  fmt.Println(m[p])
}
```

这段代码会输出什么取决于map的行为以及person类型的定义。在Go语言中，map是一种引用类型，它存储的是键值对，其中键是唯一的。当你尝试访问一个不存在的键时，map会返回该键对应类型的零值。

在这个例子中，m是一个map，它的键类型是`person`，值类型是`int`。p是一个person类型的变量，它的name字段被初始化为"张三"。

当你尝试访问`m[p]`时，由于m是一个空的map，它不包含任何键值对，因此m[p]会返回int类型的零值，即0。

所以，这段代码会输出0。

总结
这段代码会输出0，因为m是一个空的map，它不包含任何键值对，因此m[p]会返回int类型的零值，即0。


## 3.下面这段代码会输出什么？

```go
func hello(num ...int) {
  num[0] = 18
}

func main() {
  i := []int{5,6,7}
  hello(i...)
  fmt.Println(i[0])
}
```

## 解析：
这段代码会输出18，原因如下：

在Go语言中，...表示可变参数。在函数 hello 中，num ...int 表示 num 是一个可变参数，可以接收任意数量的 int 类型参数。当你调用 hello(i...) 时，i 是一个切片 []int{5, 6, 7}，i... 会将切片 i 中的所有元素作为参数传递给 hello 函数。

在 hello 函数内部，num 实际上是一个切片，因为可变参数在函数内部被当作切片处理。因此，num[0] = 18 会修改切片 num 的第一个元素，也就是 i 的第一个元素。

当你在 main 函数中调用 fmt.Println(i[0]) 时，i 的第一个元素已经被修改为 18，所以输出结果是 18。