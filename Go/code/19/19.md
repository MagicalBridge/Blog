# 第 19 天

## 1.下面代码输出什么？

```go
type Person struct {
    age  int
}

func main() {
    person := &Person{28}
    defer fmt.Println(person.age)

    defer func(p *Person) {
        fmt.Println(p.age)
    }(person)

    defer func() {
        fmt.Println(person.age)
    }()

    person.age = 29
}
```

## 解析
这段代码的输出结果为：
```
29
29
29
```

让我来详细解析原因：

1. 代码执行顺序：
   - 首先创建一个 `Person` 实例，`age` 初始值为 28
   - 注册了三个 defer 函数（按注册顺序标记为 defer1、defer2、defer3）
   - 将 person.age 修改为 29
   - 程序结束前，按照 LIFO（后进先出）的顺序执行 defer 函数

2. 具体分析每个 defer：

   - defer3（最后注册的，最先执行）：
     ```go
     defer func() {
         fmt.Println(person.age)
     }()
     ```
     这是一个闭包，直接引用外部的 person 变量，执行时会打印当前的 person.age 值（29）

   - defer2（第二个注册的，第二个执行）：
     ```go
     defer func(p *Person) {
         fmt.Println(p.age)
     }(person)
     ```
     这个函数接收一个指针参数，虽然在注册时传入了 person，但由于是指针，所以依然能够访问到修改后的值（29）

   - defer1（第一个注册的，最后执行）：
     ```go
     defer fmt.Println(person.age)
     ```
     这个 defer 语句虽然最早注册，但同样是引用的指针，所以也能获取到最新的 age 值（29）

3. 关键点说明：
   - 所有的 defer 都是在对 person.age 赋值为 29 之后执行的
   - 由于 person 是指针类型，所以所有的 defer 都能访问到最新的值
   - 如果 person 是值类型而不是指针类型，或者 defer 函数接收的是值而不是指针，结果可能会不同